import sys
"""
다른 냅색 유형과 달리 이 문제는 문제당 1번씩 풀 수 있어 중복이 불가능하다.
즉, 처음의 [0,0,0,0,a,a,a,a,2a,2a,2a,2a ......]가 되면 안된다.
이를 해결하기 위해 2차원 배열을 주로 이용하는데
a가 3이고 b가 4일 경우, 2차원 배열을 사용하면
[0,0,0,0,0,0,0,0]
[0,0,0,a,a,a,a,a] 첫 번째 빈 행을 참조하여 3 이후 열은 모두 0+a가 되고 
[0,0,0,a,b,b,b,a+b] 두 번째 행을 참조하여 4 이후 a보다 큰 b로 바뀌다가 7(3+4)이 될 때에 a+b 값이 된다.
즉 이전의 배열을 참조한다면 같은 값의 중복을 피할 수 있다.

하지만 이런 방식을 사용하면 메모리의 손실이 크기 때문에 역순으로 참조하는 방식을 주로 이용한다.
역순으로 한다면 같은 경우에서
[0,0,0,0,0,0,0,a] 마지막부터 시작하므로 4열(7-3)의 값은 0이므로 값은 a가 된다.
[0,0,0,a,a,a,a,a] 이는 a의 시작인 3까지 가더라도 0열(3-0)은 0 이므로 a가 된다. 
[0,0,0,a,b,b,b,a+b]  에서 b가 처음 들어갈 때에(7부터 시작) 4(7-3)은 a이므로 7열은 a+b가 된다 


"""
#sys.stdin = open("C:\\Users\\82103\\pythonprogramming\\algorithm\\input.txt","r")

n , m = map(int,input().split())
dy=[0]*(m+1)
ch = [[0]*(n) for _ in range(m+1)]
for i in range(n):
    a,b = map(int, input().split())
    for j in range(m,b-1, -1): #뒤에서부터 하는 이유는 중복을 피하기 위해
       dy[j] = max(dy[j-b]+a,dy[j])


print(dy[m])