---------------------------------------
#### 18290_NM과 K(1)

미해결

---------------------------------------

#### 6064_카잉달력
- 풀이접근: 

X의 주기가 M이므로 만약 answer가 x + M * t1라면 해당 answer는 y+ N*t2 여야만한다.<br>따라서 (x+M * t1-y)가 N으로 나뉘어떨어진다면 답이 될 수 있다

- 어려웠던 점:

만약 구할 수 없는 경우라면 -1을 출력해야 하는데 이 경우를 생각하지 못해 자꾸 틀렸었다.<br>answer가 M * N이 넘어버리면 즉 M의 주기와 N의 주기가 서로 만나는 경우가 와도 답이 없었다면 -1을 출력하면된다.

- 재풀이 중요도: 3
---------------------------------------
#### 3085_사탕 게임
- 풀이접근: 

브루트포스 문제답게 모든 값을 비교하면 되었다. 다만 변경을 하고 다시 원래대로 돌리는 과정이 꼭 필요했다. 

- 어려웠던 점:

answer = max(answer,temp)보다 if를 이용한 값 비교 후 대입을 하는 것이 속도에 더 이득이었다. <br> 또한 나는 속도 줄이려 만약 행을 바꿨으면 행만 비교하면 된다고 생각했지만 행이 바뀌었을 경우 오히려 그 바뀐 결과에 의해 오히려 열에서 최대값이 나오는 경우가 있다는 것을 알게 되었다.
<br>따라서 l[i][j] l[i][j+1]처럼 열이 바뀌었을 경우 바뀐 열 두 줄(j, j+1)을 체크하고 행은 바뀐 줄만 체크(i)하면 된다. 

- 재풀이 중요도: 2

---------------------------------------
#### 1107_리모컨
- 풀이접근: 

주어진 n에서부터 위로,혹은 아래로 가면서 만약 해당 숫자가 고장나지 않은 키로 이루어졌이다면 break.<br>
이 과정은 반대로 생각해보면 가능한 가까운 숫자로 이동한뒤 n으로 가는 과정을 반대로 한 것.

- 어려웠던 점:

사실 위의 아이디어는 빨리 떠올렸으나 자꾸 시간 초과가 났다. 나는 taget부터 시작해 up에는 +1을 하고 down에는 -1을 한 뒤 해당 답이 고장나지 않은 숫자로 이루어져 있으면 정답처리를 했다. 하지만 이 방식을 하면 만약 모든 키가 고장났을 때 무한루프가 도는 모습을 보였다.<br>
따라서 n부터 최대 범위까지 비교하다가 있으면 break, n부터 1까지 비교하다가 있으면 break하는 방식을 이용했다. 여기서 최대범위는 target number의 숫자가 500000이었지만 버튼으로 누를 수 있는 숫자는 무한이었다. 따라서 위에서 내려온다면 1000000으로부터 500000에 도착할 수 있으므로 1000000까지 반복문을 돌리는 게 중요했다.
- 재풀이 중요도: 3

---------------------------------------
#### 1748_수 이어쓰기 1
- 풀이접근: 

숫자는 자릿수당 9, 90, 900, 9000...이런 식으로 개수가 주어진다 따라서 일단 주어진 숫자의 자릿수를 구한 뒤 해당 자릿수 전까지 개수를 일괄처리한다.<br> 예를 들어 1001의 경우 4자리수 9 * 1 + 90 * 2 + 90 * 3을 더해준다.그리고 남은 개수를 위해 n(1001) - 이전 최대치(999)를 한 뒤 자릿수만큼 곱해준다. 2 * 4 
- 어려웠던 점:

어려웠다기 보다 내가 원하는 결과를 내기 위해 반복문을 짜는 게 조금 헷갈렸다. 아이디어가 떠오르면 코드의 구조를 생각하지 않고 바로 코딩해서 디버깅하는데 시간을 쓰는 것이 나의 큰 문제인 것 같다. 이를 염두에 두자.     
- 재풀이 중요도: 1

---------------------------------------
#### 15654_N과 M(5)
- 풀이접근: 

DFS를 통해 수열을 구한다. 하지만 이는 사전 순으로 정렬되어 있어야하므로 먼저 입력값을 정렬한 뒤 이에 대한 수열을 구해주면 된다.<br> 수열을 구하는 방법은 만약 check 배열을 만들어 이미 사용한 값이라면 check값을 1로 만들어 다음에는 무시하고 재귀를 빠져나올 때 check를 다시 0으로 바꿔 초기화하도록 한다.  
- 어려웠던 점:

내용은 쉬웠으나 DFS를 이용했기에 구현에 생각보다 시간이 걸렸다. 처음에는 list를 인자로 주는 방식으로 했으나 원하는 결과가 나오지 않아 답으로 미리 정해진 크기의 배열을 만든 뒤 안의 원소 값을 바꾸는 방식을 사용했다. 
- 재풀이 중요도: 2


---------------------------------------
#### 15657_N과 M(8)

- 풀이접근: 

5번 문제와 매우 흡사했다. 다만 이미 쓴 값을 check 하는 것이 아니라 먼저 정렬을 한 뒤 바로 직전의 값보다 작다면 넣지 않는 방식으로 했다. 

- 어려웠던 점:

딱히 없었다. N과 M(5)와 거의 흡사하므로 만약 복습할 것이라면 둘 중에 하나만 풀자

- 재풀이 중요도: 2


---------------------------------------
#### 9095_ 1, 2, 3 더하기

- 풀이접근: 

DFS로 해결했다. 경우가 3개뿐이라 for문으로 각각 넣어서 합이 같으면 개수를 카운트했다. 

- 어려웠던 점:

딱히 없었다.

- 재풀이 중요도: 1


---------------------------------------
#### 9095_ 1, 2, 3 더하기

- 풀이접근: 
먼저 정렬된 순서로 조합을 짜야하기 때문에, 리스트를 정렬한다. 그리고 모음 a,i,e,u,o 같은 경우 1 이상, 자음은 2 이상이어야 하므로 인자로 모음 개수를 넣어준다. 그리고 이런 모음 개수가 1 이상이고, 전체-모음이 >=2일 때만 진행한다.<br>
다시 말해 모음이 전체-2 이상이면 return한다. 


- 어려웠던 점:

암호 만들기, 가능한 모든 조합을 생각하고 조건이 맞지 않으면 출력하지 않는 방식을 먼저 생각했다. <br>
하지만 그 방법 보다 인자에 조건을 넣어 바로바로 체크할 수 있는 방식이 훨씬 빨랐다.<br>
한번 풀어서 맞춰본 문제인데도 다시 풀었을 때 틀렸으니 꼭 유의하고 다시보자


- 재풀이 중요도: 4
