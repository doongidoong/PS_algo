---------------------------------------
#### 18290_NM과 K(1)

미해결

---------------------------------------

#### 6064_카잉달력
- 풀이접근: 

X의 주기가 M이므로 만약 answer가 x + M * t1라면 해당 answer는 y+ N*t2 여야만한다.<br>따라서 (x+M * t1-y)가 N으로 나뉘어떨어진다면 답이 될 수 있다

- 어려웠던 점:

만약 구할 수 없는 경우라면 -1을 출력해야 하는데 이 경우를 생각하지 못해 자꾸 틀렸었다.<br>answer가 M * N이 넘어버리면 즉 M의 주기와 N의 주기가 서로 만나는 경우가 와도 답이 없었다면 -1을 출력하면된다.

- 재풀이 중요도: 3
---------------------------------------
#### 3085_사탕 게임
- 풀이접근: 

브루트포스 문제답게 모든 값을 비교하면 되었다. 다만 변경을 하고 다시 원래대로 돌리는 과정이 꼭 필요했다. 

- 어려웠던 점:

answer = max(answer,temp)보다 if를 이용한 값 비교 후 대입을 하는 것이 속도에 더 이득이었다. <br> 또한 나는 속도 줄이려 만약 행을 바꿨으면 행만 비교하면 된다고 생각했지만 행이 바뀌었을 경우 오히려 그 바뀐 결과에 의해 오히려 열에서 최대값이 나오는 경우가 있다는 것을 알게 되었다.
<br>따라서 l[i][j] l[i][j+1]처럼 열이 바뀌었을 경우 바뀐 열 두 줄(j, j+1)을 체크하고 행은 바뀐 줄만 체크(i)하면 된다. 

- 재풀이 중요도: 2

---------------------------------------
#### 1107_리모컨
- 풀이접근: 

주어진 n에서부터 위로,혹은 아래로 가면서 만약 해당 숫자가 고장나지 않은 키로 이루어졌이다면 break.<br>
이 과정은 반대로 생각해보면 가능한 가까운 숫자로 이동한뒤 n으로 가는 과정을 반대로 한 것.

- 어려웠던 점:

사실 위의 아이디어는 빨리 떠올렸으나 자꾸 시간 초과가 났다. 나는 taget부터 시작해 up에는 +1을 하고 down에는 -1을 한 뒤 해당 답이 고장나지 않은 숫자로 이루어져 있으면 정답처리를 했다. 하지만 이 방식을 하면 만약 모든 키가 고장났을 때 무한루프가 도는 모습을 보였다.<br>
따라서 n부터 최대 범위까지 비교하다가 있으면 break, n부터 1까지 비교하다가 있으면 break하는 방식을 이용했다. 여기서 최대범위는 target number의 숫자가 500000이었지만 버튼으로 누를 수 있는 숫자는 무한이었다. 따라서 위에서 내려온다면 1000000으로부터 500000에 도착할 수 있으므로 1000000까지 반복문을 돌리는 게 중요했다.
- 재풀이 중요도: 3

---------------------------------------
#### 1748_수 이어쓰기 1
- 풀이접근: 

숫자는 자릿수당 9, 90, 900, 9000...이런 식으로 개수가 주어진다 따라서 일단 주어진 숫자의 자릿수를 구한 뒤 해당 자릿수 전까지 개수를 일괄처리한다.<br> 예를 들어 1001의 경우 4자리수 9 * 1 + 90 * 2 + 90 * 3을 더해준다.그리고 남은 개수를 위해 n(1001) - 이전 최대치(999)를 한 뒤 자릿수만큼 곱해준다. 2 * 4 
- 어려웠던 점:

어려웠다기 보다 내가 원하는 결과를 내기 위해 반복문을 짜는 게 조금 헷갈렸다. 아이디어가 떠오르면 코드의 구조를 생각하지 않고 바로 코딩해서 디버깅하는데 시간을 쓰는 것이 나의 큰 문제인 것 같다. 이를 염두에 두자.     
- 재풀이 중요도: 1

---------------------------------------
#### 15654_N과 M(5)
- 풀이접근: 

DFS를 통해 수열을 구한다. 하지만 이는 사전 순으로 정렬되어 있어야하므로 먼저 입력값을 정렬한 뒤 이에 대한 수열을 구해주면 된다.<br> 수열을 구하는 방법은 만약 check 배열을 만들어 이미 사용한 값이라면 check값을 1로 만들어 다음에는 무시하고 재귀를 빠져나올 때 check를 다시 0으로 바꿔 초기화하도록 한다.  
- 어려웠던 점:

내용은 쉬웠으나 DFS를 이용했기에 구현에 생각보다 시간이 걸렸다. 처음에는 list를 인자로 주는 방식으로 했으나 원하는 결과가 나오지 않아 답으로 미리 정해진 크기의 배열을 만든 뒤 안의 원소 값을 바꾸는 방식을 사용했다. 
- 재풀이 중요도: 2


---------------------------------------
#### 15657_N과 M(8)

- 풀이접근: 

5번 문제와 매우 흡사했다. 다만 이미 쓴 값을 check 하는 것이 아니라 먼저 정렬을 한 뒤 바로 직전의 값보다 작다면 넣지 않는 방식으로 했다. 

- 어려웠던 점:

딱히 없었다. N과 M(5)와 거의 흡사하므로 만약 복습할 것이라면 둘 중에 하나만 풀자

- 재풀이 중요도: 2


---------------------------------------
#### 9095_ 1, 2, 3 더하기

- 풀이접근: 

DFS로 해결했다. 경우가 3개뿐이라 for문으로 각각 넣어서 합이 같으면 개수를 카운트했다. 

- 어려웠던 점:

딱히 없었다.

- 재풀이 중요도: 1


---------------------------------------
#### 9095_ 1, 2, 3 더하기

- 풀이접근: 
먼저 정렬된 순서로 조합을 짜야하기 때문에, 리스트를 정렬한다. 그리고 모음 a,i,e,u,o 같은 경우 1 이상, 자음은 2 이상이어야 하므로 인자로 모음 개수를 넣어준다. 그리고 이런 모음 개수가 1 이상이고, 전체-모음이 >=2일 때만 진행한다.<br>
다시 말해 모음이 전체-2 이상이면 return한다. 


- 어려웠던 점:

암호 만들기, 가능한 모든 조합을 생각하고 조건이 맞지 않으면 출력하지 않는 방식을 먼저 생각했다. <br>
하지만 그 방법 보다 인자에 조건을 넣어 바로바로 체크할 수 있는 방식이 훨씬 빨랐다.<br>
한번 풀어서 맞춰본 문제인데도 다시 풀었을 때 틀렸으니 꼭 유의하고 다시보자


- 재풀이 중요도: 4


---------------------------------------
#### 15661_ 링크와 스타트

- 풀이접근: 
링크 스타트, 두 팀으로 나누는 문제이다. 이런 두 팀을 나누는 문제는 먼저 한 팀의 인원을 결정지으면 자동으로 나머지 팀이 되기 때문에 한 팀만 구해주면 된다. <br>
또한 이런 문제에서 팀의 순서는 상관없기 때문에 첫번째 원소는 고정해주고 두 번째부터의 조합만 고려하면 된다. 이럴 경우 0,1,2 와 3,4,5를 두 번하는 낭비가 생기지 않는다. <br>
그런데 이 문제에서 중요한 점은 팀의 인원수가 같지 않아도 된다는 것이었다. 이 때문에 팀의 인원수를 절반(N//2)으로 해서 return 하는 게 아니라 반복문을 통해 0부터 n-1까지 모두 고려해주어야 한다. 즉 네 명이라면 [ 0 ], [ 0 , 1 ] , [ 0 , 2]  [ 0, 3] , [ 0 , 1 , 2], [0, 1, 3] , [0, 2,3]을 고려해주면 된다.


- 어려웠던 점:

결과가 겹치는 부분이 보여 이를 줄이는 데에 고민을 많이 했다. 
인원 수가 같지 않아도 된다는 점에서 return하는 Level을 인자로 넣어준다는 생각은 금방 떠올렸지만 result 크기에서 에러가 났다. 이런 부분을 유의하면서 코딩하자


- 재풀이 중요도: 3

---------------------------------------
#### 14501_퇴사

- 풀이접근: 
리스트 하나에는 Time을, 하나에는 점수를 넣어 DFS를 돌린다. DFS 인자로는 레벨과 지금까지 점수의 총합을 넣고 time만큼 레벨을 증가시키면 된다. <br>
만약 해당 날짜를 건너뛰려면 레벨만 올리고 t에 현재 점수를 더하지 않으면 된다.


- 어려웠던 점:

DFS 유형의 대표 문제 같은 느낌이었다. DP로도 풀 수 있을 것 같은데 추후 다시 풀어보자.


- 재풀이 중요도: 3

---------------------------------------
#### 2529_부등호

- 풀이접근: 

조금 뒤에 추가

- 어려웠던 점:


- 재풀이 중요도: 3

---------------------------------------
#### 10972_다음 순열(미해결)

- 풀이접근: 


- 어려웠던 점:
시간초과를 해결하지 못했다. 꼭 다시 풀어보자


- 재풀이 중요도: 5


---------------------------------------
#### 10973_이전 순열(미해결)

- 풀이접근: 

- 어려웠던 점:
시간초과를 해결하지 못했다. 꼭 다시 풀어보자


- 재풀이 중요도: 5

---------------------------------------
#### 18290_NM과 K(미해결)

- 풀이접근: 
주위 위아래 4 방향으로 이미 방문했을 경우, 해당 칸은 사용할 수 없다. 이를 위해 check를 만들어 해당 칸을 방문했을 경우, continue <br>
해당 칸 주위 4칸이 이미 방문했을 경우, continue하는 방법으로 DFS를 구성했다.
여기서 중요한 점은 0~n까지 모두 비교할 경우 시간복잡도가 너무 높아 시간초과가 나온다. 따라서 같은 행에서도 중복된 선택을 피하기 위해서 이전에 선택한 행과 같은 행인 경우와 아닌 경우로 나눠 문제를 해결한다.

- 어려웠던 점:
시간초과를 해결하지 못했다. 꼭 다시 풀어보자

- 재풀이 중요도: 5


---------------------------------------
#### 스타트와 링크

- 풀이접근: 

- 어려웠던 점:

- 재풀이 중요도: 3