#### 6064_카잉달력
- 풀이접근: 

X의 주기가 M이므로 만약 answer가 x + M*t1라면 해당 answer는 y+ N*t2 여야만한다.<br>따라서 (x+M*t1-y)가 N으로 나뉘어떨어진다면 답이 될 수 있다

- 어려웠던 점:

만약 구할 수 없는 경우라면 -1을 출력해야 하는데 이 경우를 생각하지 못해 자꾸 틀렸었다.<br>answer가 M*N이 넘어버리면 즉 M의 주기와 N의 주기가 서로 만나는 경우가 와도 답이 없었다면 -1을 출력하면된다.

- 재풀이 중요도: 3
---------------------------------------
#### 3085_사탕 게임
- 풀이접근: 

브루트포스 문제답게 모든 값을 비교하면 되었다. 다만 변경을 하고 다시 원래대로 돌리는 과정이 꼭 필요했다. 

- 어려웠던 점:

answer = max(answer,temp)보다 if를 이용한 값 비교 후 대입을 하는 것이 속도에 더 이득이었다. <br> 또한 나는 속도 줄이려 만약 행을 바꿨으면 행만 비교하면 된다고 생각했지만 행이 바뀌었을 경우 오히려 그 바뀐 결과에 의해 오히려 열에서 최대값이 나오는 경우가 있다는 것을 알게 되었다.
<br>따라서 l[i][j] l[i][j+1]처럼 열이 바뀌었을 경우 바뀐 열 두 줄(j, j+1)을 체크하고 행은 바뀐 줄만 체크(i)하면 된다. 

- 재풀이 중요도: 2

---------------------------------------
#### 1107_리모컨
- 풀이접근: 

주어진 n에서부터 위로,혹은 아래로 가면서 만약 해당 숫자가 고장나지 않은 키로 이루어졌이다면 break.<br>
이 과정은 반대로 생각해보면 가능한 가까운 숫자로 이동한뒤 n으로 가는 과정을 반대로 한 것.

- 어려웠던 점:

사실 위의 아이디어는 빨리 떠올렸으나 자꾸 시간 초과가 났다. 나는 taget부터 시작해 up에는 +1을 하고 down에는 -1을 한 뒤 해당 답이 고장나지 않은 숫자로 이루어져 있으면 정답처리를 했다. 하지만 이 방식을 하면 만약 모든 키가 고장났을 때 무한루프가 도는 모습을 보였다.<br>
따라서 n부터 최대 범위까지 비교하다가 있으면 break, n부터 1까지 비교하다가 있으면 break하는 방식을 이용했다. 여기서 최대범위는 target number의 숫자가 500000이었지만 버튼으로 누를 수 있는 숫자는 무한이었다. 따라서 위에서 내려온다면 1000000으로부터 500000에 도착할 수 있으므로 1000000까지 반복문을 돌리는 게 중요했다.
- 재풀이 중요도: 3