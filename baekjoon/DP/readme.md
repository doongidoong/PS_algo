
#### 1463_1로 만들기
- 풀이접근: 
<p>
총 경우의 수는 세 가지가 있다. dy[i - 1], dy[i / 2], dy[i / 3] 먼저 dy[ 1 ] = 0로 설정해놓고 가장 최소의 값을 dy로 한다. 


- 어려웠던 점:
가장 간단한 dp 문제, 주의할 점은 6으로 나눠질 경우 3과 2 모두 고려해야 한다는 점이다. 

- 재풀이 중요도: 1

---------------------------------------

#### 16194_카드 구매하기 2

- 풀이접근: 
<p>
주어진 카드를 구매하는 데에 있어서 모든 경우를 고민한다. 이 때, 가장 작은 값으로 dy를 갱신하면 된다.<br>

예를 들면 3의 값이 주어졌다고 보자. 이 3의 값은 dy1+dy1+dy1과 dy2+dy1, dy3 중 가장 작은 값이어야만 한다.<br>
이를 위해 우리는 카드를 1개 사는 경우부터 3개를 사는 경우까지, min(dy[i-1]+ dy[1], dy [i] ) ~ min(dy [i -3]+ dy [3], dy [i])를 비교한다. 다시 말해, i를 n까지 루프하면서 dy[i-k] + dy[k]보다 크다면 갱신한다. 

<br> 그런데 여기서 한 가지 주의할 점은 k가 n까지가 아닌 n//2까지만 비교해도 상관없다는 것이다. <br> 그 이유를 예로 들자면, n이 4일 경우, k = 3일 때 4는 dy[4-3] + dy[3]과 비교하게 되는데 이는 이전에 k = 1일때, dy [4-1] + dy [3]으로 이미 체크한 경우이기 때문이다. 

- 어려웠던 점:

갱신 과정이 바로 떠오르지 않았다 bottom up은 작은 값부터 시작한다는 것을 명심하자. 카드 구매하기 1을 다시 풀어보자.

- 재풀이 중요도: 2


---------------------------------------

#### 15990_1, 2, 3 더하기 5

- 풀이접근: 
<p>
가능한 숫자는 1, 2, 3 인데 수가 연속되면 안된다는 조건이 있다. 이러한 조건을 지키기 위해서는 모든 경우의 첫 수가 가장 중요하다.<br> 

일단 먼저 가능한 경우를 생각해보자. 예를 들어, 5를 만드는 데에 3가지로 나눠볼 수 있다. <br>
만약 첫 번째 수를 고정한다고 가정하고, 1 + 5-1, 2 + 5-2, 3 + 5-3 이런 방법으로 나타낼 수 있다. 즉, dy[i-1], dy[i-2], dy[i-3]만큼 경우의 수가 있을 수 있다. <br>

하지만 연속된 숫자는 불가하므로 1의 경우 4가 만들어진 경우의 수에서 1로 시작하는 만큼 제외해야한다. <br>
이를 위해 나는 dy[i]를 총 3개의 칸으로 만들어 0번 인덱스는 1을 사용한 경우, 1번은 2, 2번은 3을 사용한 경우를 넣었다. 
이를 식으로 표현하면 dy[5][0] = dy [4][1] + dy[4][2], dy[5][1] = dy[4][0]+dy[4][2] , dy[5][2] = dy[4][0]+dy[4][1]으로 나타낼 수 있다.

- 어려웠던 점:

시간 초과가 자꾸 떴다. 풀이는 맞았지만 10000009로 나누어주는 것을 마지막 값에만 하는 것이 아니라 애초에 dp에 저장할 때도 나눠주는 것이 속도 향상이 큰 효율을 보인다. 다시 풀 필요는 없고 이를 기억하도록 하자!!

- 재풀이 중요도: 3

---------------------------------------

#### 14002_가장 긴 증가하는 부분 수열 4

- 풀이접근: 
<p>
dp의 대표적인 알고리즘 중 하나인 LIS를 활용한 문제였다. 이중 for문으로 dy[i]= i보다 작은 i 이전까지 가장 큰 dy + 1을 이용하면 된다.<br>
하지만 이 문제에서 중요한 점은 단지 길이만 구하는 것이 아니라 수열 자체를 저장해야 하기 때문에 나는 수열을 저장하는 리스트를 또 만들어 dy가 갱신될 때 같이 수열을 또한 저장했다.  


- 어려웠던 점:

그런데 이 문제에서는 메모리 초과가 발생하지 않았지만 만약 n이 커진다면 메모리 초과가 발생할 수 있을 것 같다. 조금 더 고민이 필요할 것 같다.

- 재풀이 중요도: 4


---------------------------------------

#### 1309_동물원 미해결

- 풀이접근: 
<p>
n이 늘어가면서 바로 이전 dp에서 왼쪽 칸에 사자가 있었을 경우, 오른쪽 칸에 사자가 있었을 경우, 없었을 경우로 분류해서 푼다.

- 어려웠던 점:



- 재풀이 중요도: 5



---------------------------------------

#### 1149_RGB 거리

- 풀이접근: 
<p>
i번째를 칠하는 경우는 총 세 가지가 있다. 빨강, 초록, 파랑.<br> 
여기서 중요한 점은 만약 초록을 선택한다면 바로 위 i-1의 색은 파랑 혹은 빨강이어야 한다는 것이다.<br>
즉, i이 초록이라면 i-1의 파랑과 빨강 중 작은 값이 선택된다는 것을 전제한다. 이 때문에 d[i][0] += min(d[i-1][1],d[i-1][2])이라는 식이 도출된다.<br>
이를 이용해 각각 마지막의 경우가 빨강, 초록, 파랑을 모두 구한 뒤, 가장 작은 값을 선택한다.   


- 어려웠던 점:
DP를 풀 때, 다중 배열을 사용해서 푸는 것이 익숙하지 않은 것 같다. 이 문제와 바로 위 문제인 동물원 문제에서처럼 여러 선택지가 있으면, 해당 선택지가 선택할 수 있는 경우를 dp에 다중 배열로 저장하는 것을 고민해보자.  

- 재풀이 중요도: 5

---------------------------------------

#### 11057_오르막 수

- 풀이접근: 
<p>
오르막 수의 기준이 같은 수도 포함이다 .따라서 가능한 경우의 수는 이전의 수가 작거나 같은 경우이다. 
<br>이를 예를 들어 표현하면 만약 이전 수가 0일 경우, 가능한 경우는 0 뿐이다. 하지만 0이 아닐 경우는 같은 레벨의 바로 아래 수(1일 경우 0)의 경우와 이전 레벨의 같은 수의 경우를 합한 것과 같다. 
<br> 왜냐하면 작은 수가 가능한 경우는 그보다 높은 수는 당연히 가능할 것이고, 거기에다가 추가되는 것은 수가 같은 경우 뿐이기 때문이다. 

- 어려웠던 점:
다중 배열을 생각하면 쉽게 풀린다. 하지만 처음 생각할 때, 이전 레벨의 작은 경우를 모두 더하는 경우를 생각했으나 그럴 필요 없이 같은 레벨의 바로 직전의 수만 더하면 된다는 것을 깨달았다. 

- 재풀이 중요도: 2