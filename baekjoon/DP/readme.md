
#### 1463_1로 만들기
- 풀이접근: 
<p>
총 경우의 수는 세 가지가 있다. dy[i - 1], dy[i / 2], dy[i / 3] 먼저 dy[ 1 ] = 0로 설정해놓고 가장 최소의 값을 dy로 한다. 


- 어려웠던 점:
가장 간단한 dp 문제, 주의할 점은 6으로 나눠질 경우 3과 2 모두 고려해야 한다는 점이다. 

- 재풀이 중요도: 1

---------------------------------------

#### 16194_카드 구매하기 2

- 풀이접근: 
<p>
주어진 카드를 구매하는 데에 있어서 모든 경우를 고민한다. 이 때, 가장 작은 값으로 dy를 갱신하면 된다.<br>

예를 들면 3의 값이 주어졌다고 보자. 이 3의 값은 dy1+dy1+dy1과 dy2+dy1, dy3 중 가장 작은 값이어야만 한다.<br>
이를 위해 우리는 카드를 1개 사는 경우부터 3개를 사는 경우까지, min(dy[i-1]+ dy[1], dy [i] ) ~ min(dy [i -3]+ dy [3], dy [i])를 비교한다. 다시 말해, i를 n까지 루프하면서 dy[i-k] + dy[k]보다 크다면 갱신한다. 

<br> 그런데 여기서 한 가지 주의할 점은 k가 n까지가 아닌 n//2까지만 비교해도 상관없다는 것이다. <br> 그 이유를 예로 들자면, n이 4일 경우, k = 3일 때 4는 dy[4-3] + dy[3]과 비교하게 되는데 이는 이전에 k = 1일때, dy [4-1] + dy [3]으로 이미 체크한 경우이기 때문이다. 

- 어려웠던 점:

갱신 과정이 바로 떠오르지 않았다 bottom up은 작은 값부터 시작한다는 것을 명심하자. 카드 구매하기 1을 다시 풀어보자.

- 재풀이 중요도: 2


---------------------------------------

#### 15990_1, 2, 3 더하기 5

- 풀이접근: 
<p>
가능한 숫자는 1, 2, 3 인데 수가 연속되면 안된다는 조건이 있다. 이러한 조건을 지키기 위해서는 모든 경우의 첫 수가 가장 중요하다.<br> 

일단 먼저 가능한 경우를 생각해보자. 예를 들어, 5를 만드는 데에 3가지로 나눠볼 수 있다. <br>
만약 첫 번째 수를 고정한다고 가정하고, 1 + 5-1, 2 + 5-2, 3 + 5-3 이런 방법으로 나타낼 수 있다. 즉, dy[i-1], dy[i-2], dy[i-3]만큼 경우의 수가 있을 수 있다. <br>

하지만 연속된 숫자는 불가하므로 1의 경우 4가 만들어진 경우의 수에서 1로 시작하는 만큼 제외해야한다. <br>
이를 위해 나는 dy[i]를 총 3개의 칸으로 만들어 0번 인덱스는 1을 사용한 경우, 1번은 2, 2번은 3을 사용한 경우를 넣었다. 
이를 식으로 표현하면 dy[5][0] = dy [4][1] + dy[4][2], dy[5][1] = dy[4][0]+dy[4][2] , dy[5][2] = dy[4][0]+dy[4][1]으로 나타낼 수 있다.

- 어려웠던 점:

시간 초과가 자꾸 떴다. 풀이는 맞았지만 10000009로 나누어주는 것을 마지막 값에만 하는 것이 아니라 애초에 dp에 저장할 때도 나눠주는 것이 속도 향상이 큰 효율을 보인다. 다시 풀 필요는 없고 이를 기억하도록 하자!!

- 재풀이 중요도: 3

---------------------------------------

#### 14002_가장 긴 증가하는 부분 수열 4

- 풀이접근: 
<p>
dp의 대표적인 알고리즘 중 하나인 LIS를 활용한 문제였다. 이중 for문으로 dy[i]= i보다 작은 i 이전까지 가장 큰 dy + 1을 이용하면 된다.<br>
하지만 이 문제에서 중요한 점은 단지 길이만 구하는 것이 아니라 수열 자체를 저장해야 하기 때문에 나는 수열을 저장하는 리스트를 또 만들어 dy가 갱신될 때 같이 수열을 또한 저장했다.  


- 어려웠던 점:

그런데 이 문제에서는 메모리 초과가 발생하지 않았지만 만약 n이 커진다면 메모리 초과가 발생할 수 있을 것 같다. 조금 더 고민이 필요할 것 같다.

- 재풀이 중요도: 4


---------------------------------------

#### 1309_동물원 미해결

- 풀이접근: 
<p>
n이 늘어가면서 바로 이전 dp에서 왼쪽 칸에 사자가 있었을 경우, 오른쪽 칸에 사자가 있었을 경우, 없었을 경우로 분류해서 푼다.

- 어려웠던 점:



- 재풀이 중요도: 5



---------------------------------------

#### 1149_RGB 거리

- 풀이접근: 
<p>
i번째를 칠하는 경우는 총 세 가지가 있다. 빨강, 초록, 파랑.<br> 
여기서 중요한 점은 만약 초록을 선택한다면 바로 위 i-1의 색은 파랑 혹은 빨강이어야 한다는 것이다.<br>
즉, i이 초록이라면 i-1의 파랑과 빨강 중 작은 값이 선택된다는 것을 전제한다. 이 때문에 d[i][0] += min(d[i-1][1],d[i-1][2])이라는 식이 도출된다.<br>
이를 이용해 각각 마지막의 경우가 빨강, 초록, 파랑을 모두 구한 뒤, 가장 작은 값을 선택한다.   


- 어려웠던 점:
DP를 풀 때, 다중 배열을 사용해서 푸는 것이 익숙하지 않은 것 같다. 이 문제와 바로 위 문제인 동물원 문제에서처럼 여러 선택지가 있으면, 해당 선택지가 선택할 수 있는 경우를 dp에 다중 배열로 저장하는 것을 고민해보자.  

- 재풀이 중요도: 5

---------------------------------------

#### 11057_오르막 수

- 풀이접근: 
<p>
오르막 수의 기준이 같은 수도 포함이다 .따라서 가능한 경우의 수는 이전의 수가 작거나 같은 경우이다. 
<br>이를 예를 들어 표현하면 만약 이전 수가 0일 경우, 가능한 경우는 0 뿐이다. 하지만 0이 아닐 경우는 같은 레벨의 바로 아래 수(1일 경우 0)의 경우와 이전 레벨의 같은 수의 경우를 합한 것과 같다. 
<br> 왜냐하면 작은 수가 가능한 경우는 그보다 높은 수는 당연히 가능할 것이고, 거기에다가 추가되는 것은 수가 같은 경우 뿐이기 때문이다. 

- 어려웠던 점:
다중 배열을 생각하면 쉽게 풀린다. 하지만 처음 생각할 때, 이전 레벨의 작은 경우를 모두 더하는 경우를 생각했으나 그럴 필요 없이 같은 레벨의 바로 직전의 수만 더하면 된다는 것을 깨달았다. 

- 재풀이 중요도: 2

---------------------------------------

#### 2225_합분해(미해결)

- 풀이접근: 
<p>
오르막 수와 풀이 과정이 비슷하다. 이전 레벨에서 n보다 작거나 같은 경우의 합을 dp에 넣어주면 된다.
<br> 예를 들어 설명하면, n은 6까지 있다고 가정하자. 그럼 먼저 k=1일 때, 가능한 경우는 덧셈이 없으므로 바로 n 자기 자신일 때만 가능하다. 이 경우를 나타내면 각각 n=0이면 0 하나이므로 경우의 수는 1, n=2 또한 2 하나이므로 n 값에 관계 없이 모두 1로 동일하다.  
<br> 그럼 k=2일 때는 어떻게 되는가. 우리는 이제 숫자 하나를 더 사용해서 n을 만족해야 한다. 이를 다시 예로 설명하겠다. <br>  
k=1일 때는 경우의 수는 하나였지만 그 값은 사실 각각 0, 1, 2, 3, 4, 5, 6 이라는 값을 가지며 조건을 만족했다. 그런데 우리는 여기에다가 적절한 수를 더함으로 k=2일 때가 만족시킬 수 있다. 즉, 이전이 0이었다고 가정하면, +6을 함으로 이를 만족한다. 1이면 +5, 2이면 +4, ... 6이면 +0. 다시 말해, k=1일 때의 n보다 작거나 같은 모든 경우가 k=2일 때 n을 만족하는 경우로 만들어질 수 있다. 
<br>다시 설명하자면, 일단 k-1 개의 수로 n을 초과하지 않는 숫자를 만들어놓고 나면 거기에다가 알맞은 값을 더함으로 우리는 k일 때, n을 만족시킬 수 있다. 따라서 k-1 개의 수로 n을 초과하지 않는 숫자를 만드는 경우의 수가 바로 sum(dp[k-1][0]~dp[k-1][n])이다. 

<br> 이를 리스트로 나타내면 k=1일 경우, [1,1,1,1,1,1,1]이 나온다. 
<br> 그리고 k=2일 경우, [(1),(1+1),(1+1+1),...,7]을 구할 수 있다.
<br> 마지막으로 k=3일 경우, [(1),(1+2),(1+2+3)...(1+2+3+...+7)]이라는 것을 알 수 있다.
<br> 그런데 여기서 중요한 점은, sum(dp[k-1][0]~dp[k-1][n])가 사실, dp[k-1][n] + dp[k][n-1]과 동일하다는 것이다. 이는 점화식을 세워보면 알 수 있다. 그러므로 dp에 저장되는 값은 dp[i-1][j] + dp[i][j-1]이라는 것을 알 수 있다.

- 어려웠던 점:
직관적으로 경우가 떠오르지 않았다. 또한 작거나 같은 경우를 sum()하는 과정이 dp[i-1][j] + dp[i][j-1]로 이어진다는 것을 떠올리지 못했다.

- 재풀이 중요도: 4

---------------------------------------

#### 2156_포도주 시식(미해결)

- 풀이접근: 
<p>
해당 문제는 연속적으로 3개를 택할 수 없다. 그러므로 만약 i와 i-1을 택하려면, i-2만 택하지 않고 i-3 이전에는 택하든 상관없다. 반면 만약 i는 택하지만 i-1를 택하지 않을 때는, i-2까지의 최대 값을 선택하도록 한다. 이럴 경우, 설령 i-2가 택하는 경우라도 i-1이 비워져 있기에 연속하지 않는다. 그런데 여기서 한 가지 중요한 점은 i를 택하지 않는 것이 최대값이 나올 수 있다는 것이다. 현재의 두 경우는 i는 필수적으로 선택하고 i-3과 i-2의 최댓값을 가져오는 형태이다. 그러므로 이런 상황은 i-1, i-2를 선택하는 경우가 없다. 가져오는 dy[i-2]를 [i-2 + dy[i-4]]와 [i-2 + dy[i-5]] 중 높은 값이라고 볼 수 있는데, 여기서 최대값이 i-2를 택하지 않고, i-3, i-4를 택하는 경우라고 생각하자. 이럴 경우 분명, i-3, i-4 모두 i와 연속되지 않으므로 우리는 i, i-1, i-3, i-4라는 결과를 구할 수 있는데, 현재의 경우는 반드시 i, i-2, i-4, i-5 나 i, i-2, i-3을 고르는 경우 밖에 주어지지 않는다.   

<br>
이를 예시로 나타내자면, [6 10 13 9 8 1 1 2 4] 있다고 하자. dy[0]=0, dy[1] = 6, dy[2]= 6+10이다. 그런데 이 때 만약 dy[i-1]를 고려하지 않는 경우 [6 16 23 28 33 32 34 36 38] 이라는 결과가 나온다. 마지막 값은 dy[i-2]+L[i-1]+L[i]의 경우인데, dy[i-2]은 33(6+10+9+8)이라는 값을 가질 수 있지만 32(10+13+8+1)라는 값으로 저장되어 버린다.(9+8을 골라도 L[6]부터는 문제 없음)
따라서 우리가 세울 점화식은, dy[i]= max(dy[i-1],dy[i-2]+L[i],L[i-1]+dy[i-3]+L[i])로 볼 수 있다.

- 어려웠던 점:
DP의 대표격 문제인데, 틀린 것이 조금 부끄럽다. 꼭 다시 풀어보고 완벽히 숙지하자. 항상 이전 연산의 결과가 다음에 어떤 영향으로 이어지는 지 공부하자.

- 재풀이 중요도: 4