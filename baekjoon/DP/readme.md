
#### 1463_1로 만들기
- 풀이접근: 
총 경우의 수는 세 가지가 있다. dy[i - 1], dy[i / 2], dy[i / 3] 먼저 dy[ 1 ] = 0로 설정해놓고 가장 최소의 값을 dy로 한다. 


- 어려웠던 점:
가장 간단한 dp 문제, 주의할 점은 6으로 나눠질 경우 3과 2 모두 고려해야 한다는 점이다. 

- 재풀이 중요도: 1

---------------------------------------

#### 16194_카드 구매하기 2

- 풀이접근: 
<p>
주어진 카드를 구매하는 데에 있어서 모든 경우를 고민한다. 이 때, 가장 작은 값으로 dy를 갱신하면 된다.<br>

예를 들면 3의 값이 주어졌다고 보자. 이 3의 값은 dy1+dy1+dy1과 dy2+dy1, dy3 중 가장 작은 값이어야만 한다.<br>
이를 위해 우리는 카드를 1개 사는 경우부터 3개를 사는 경우까지, min(dy[i-1]+ dy[1], dy [i] ) ~ min(dy [i -3]+ dy [3], dy [i])를 비교한다. 다시 말해, i를 n까지 루프하면서 dy[i-k] + dy[k]보다 크다면 갱신한다. 

<br> 그런데 여기서 한 가지 주의할 점은 k가 n까지가 아닌 n//2까지만 비교해도 상관없다는 것이다. <br> 그 이유를 예로 들자면, n이 4일 경우, k = 3일 때 4는 dy[4-3] + dy[3]과 비교하게 되는데 이는 이전에 k = 1일때, dy [4-1] + dy [3]으로 이미 체크한 경우이기 때문이다. 

- 어려웠던 점:

갱신 과정이 바로 떠오르지 않았다 bottom up은 작은 값부터 시작한다는 것을 명심하자. 카드 구매하기 1을 다시 풀어보자.

- 재풀이 중요도: 2


---------------------------------------

#### 15990_1, 2, 3 더하기 5

- 풀이접근: 
<p>
가능한 숫자는 1, 2, 3 인데 수가 연속되면 안된다는 조건이 있다. 이러한 조건을 지키기 위해서는 모든 경우의 첫 수가 가장 중요하다.<br> 

일단 먼저 가능한 경우를 생각해보자. 예를 들어, 5를 만드는 데에 3가지로 나눠볼 수 있다. <br>
만약 첫 번째 수를 고정한다고 가정하고, 1 + 5-1, 2 + 5-2, 3 + 5-3 이런 방법으로 나타낼 수 있다. 즉, dy[i-1], dy[i-2], dy[i-3]만큼 경우의 수가 있을 수 있다. <br>

하지만 연속된 숫자는 불가하므로 1의 경우 4가 만들어진 경우의 수에서 1로 시작하는 만큼 제외해야한다. <br>
이를 위해 나는 dy[i]를 총 3개의 칸으로 만들어 0번 인덱스는 1을 사용한 경우, 1번은 2, 2번은 3을 사용한 경우를 넣었다. 
이를 식으로 표현하면 dy[5][0] = dy [4][1] + dy[4][2], dy[5][1] = dy[4][0]+dy[4][2] , dy[5][2] = dy[4][0]+dy[4][1]으로 나타낼 수 있다.

- 어려웠던 점:

시간 초과가 자꾸 떴다. 풀이는 맞았지만 10000009로 나누어주는 것을 마지막 값에만 하는 것이 아니라 애초에 dp에 저장할 때도 나눠주는 것이 속도 향상이 큰 효율을 보인다. 다시 풀 필요는 없고 이를 기억하도록 하자!!

- 재풀이 중요도: 3

